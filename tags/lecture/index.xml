<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lecture | Simon Renger</title><link>/tags/lecture/</link><atom:link href="/tags/lecture/index.xml" rel="self" type="application/rss+xml"/><description>lecture</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Simon Renger 2022</copyright><lastBuildDate>Thu, 02 Dec 2021 00:00:00 +0100</lastBuildDate><image><url>/img/icon-192.png</url><title>lecture</title><link>/tags/lecture/</link></image><item><title>C++ Compilation process</title><link>/posts/cpp_compilation_process/</link><pubDate>Thu, 02 Dec 2021 00:00:00 +0100</pubDate><guid>/posts/cpp_compilation_process/</guid><description>&lt;blockquote>
&lt;p>This is a workshop created for &lt;a href="https://www.buas.nl/en/programmes/creative-media-and-game-technologies">Breda University of Applied Sciences&lt;/a> 2021 with the original title: &lt;code>C++ Compilation process Workshop 2021&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>In this workshop / how to you learn how the C++ Compilation process works in a nutshell. Before you can start you need to do some form of preps as described in the next step.&lt;/p>
&lt;h2 id="preparations">Preparations&lt;/h2>
&lt;p>In order to participate you need to install the right compiler and linker.&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;p>If we have Visual Studio 19/22 installed with the C++ extensions or VS Code with the C++ tooling we have our linker and compiler installed.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> How to use the compiler from the command line follow this guide &lt;a href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Linux&lt;/strong> Debain/Ubuntu&lt;/p>
&lt;p>On Linux we need to install the basic build essentials. This includes the default compiler (usually GCC GNU C Compiler) and the linker&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> if you want to use the WSL follow these instructions &lt;a href="https://docs.microsoft.com/en-us/windows/wsl/install">https://docs.microsoft.com/en-us/windows/wsl/install&lt;/a> and than use the windows store / Microsoft store and download Ubuntu or Debian&lt;/p>
&lt;/blockquote>
&lt;p>Install (gcc):&lt;/p>
&lt;pre>&lt;code>sudo apt update
sudo apt install build-essential
gcc --version
&lt;/code>&lt;/pre>
&lt;p>Install (clang)&lt;/p>
&lt;pre>&lt;code>sudo apt update
sudo apt install clang
clang --version
&lt;/code>&lt;/pre>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The C/C++ compilation process takes one source file at the time and creates a Translation unit of them. Individually they do not now anything of each other! The linker will combine them at the end.&lt;/p>
&lt;p>The compilation process of a translation unit (TU) looks as following:&lt;/p>
&lt;ol>
&lt;li>Source files are cleaned&lt;/li>
&lt;li>We parse the file and run the pre-processor
&lt;ol>
&lt;li>each introduced include goes into step 1&lt;/li>
&lt;li>All pre-processor directives are removed from the source.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Literal strings and characters are translated&lt;/li>
&lt;li>Compilation takes place of tokens: &lt;em>translation units&lt;/em>&lt;/li>
&lt;li>Template instanton happens &lt;code>instantiation units&lt;/code>&lt;/li>
&lt;li>Linking&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> Some compilers don&amp;rsquo;t implement instantiation units (also known as &lt;a href="http://docs.oracle.com/cd/E18659_01/html/821-1383/bkagr.html#scrolltoc">template repositories&lt;/a> or &lt;a href="http://www-01.ibm.com/support/knowledgecenter/SSXVZZ_12.1.0/com.ibm.xlcpp121.linux.doc/compiler_ref/fcat_template.html?lang=en">template registries&lt;/a>) and simply compile each template instantiation at Phase 7 (4), storing the code in the object file where it is implicitly or explicitly requested, and then the linker collapses these compiled instantiations into one at Phase 9 (6). (&lt;a href="https://en.cppreference.com/w/cpp/language/translation_phases">https://en.cppreference.com/w/cpp/language/translation_phases&lt;/a>)&lt;/p>
&lt;/blockquote>
&lt;h2 id="pre-processor">Pre-processor&lt;/h2>
&lt;p>Did we not forget the pre-processor?&lt;/p>
&lt;pre>&lt;code>#define value 1
// I am a comment
int main(){
int var{value};
}
&lt;/code>&lt;/pre>
&lt;p>If we now compile this we can store the pre processor output in a file:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /c /P preprocessor.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>gcc preprocessor.cpp -E&amp;gt;preprocessor.i
clang preprocessor.cpp -E&amp;gt;preprocessor.i
&lt;/code>&lt;/pre>
&lt;p>We now see a file names: &lt;code>preprocessor.i&lt;/code> :&lt;/p>
&lt;pre>&lt;code>#line 1 &amp;quot;preprocessor.cpp&amp;quot;
int main(){
int var{1};
}
&lt;/code>&lt;/pre>
&lt;p>The line &lt;code>int var{value};&lt;/code> has been changed to &lt;code>int var{1};&lt;/code> and the &lt;code>#define value 1&lt;/code> was erased! Also the comment was removed!&lt;/p>
&lt;h3 id="inclusion">Inclusion&lt;/h3>
&lt;p>If you include any header file the pre processor will include them recursively.&lt;/p>
&lt;pre>&lt;code>headerA.hpp
struct StructA{};
headerB.hpp
#include &amp;quot;headerA.hpp&amp;quot;
struct StructB{};
source.cpp
#include &amp;quot;headerB.hpp&amp;quot;
int main(){
StructA struct_a{};
}
&lt;/code>&lt;/pre>
&lt;p>If we now compile this we can store the pre processor output in a file:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /c /P source.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-c">gcc preprocessor.cpp -E&amp;gt;preprocessor.i
clang preprocessor.cpp -E&amp;gt;preprocessor.i
&lt;/code>&lt;/pre>
&lt;p>We now see a file names: &lt;code>source.i&lt;/code> or &lt;code>linux&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-cpp"># 1 &amp;quot;preprocessor/source.cpp&amp;quot;
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 1
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 3
# 383 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 3
# 1 &amp;quot;&amp;lt;command line&amp;gt;&amp;quot; 1
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 2
# 1 &amp;quot;preprocessor/source.cpp&amp;quot; 2
# 1 &amp;quot;preprocessor/headerB.hpp&amp;quot; 1
# 1 &amp;quot;preprocessor/headerA.hpp&amp;quot; 1
struct StructA{};
# 2 &amp;quot;preprocessor/headerB.hpp&amp;quot; 2
struct StructB{};
# 2 &amp;quot;preprocessor/source.cpp&amp;quot; 2
int main(){
StructA struct_a{};
}
&lt;/code>&lt;/pre>
&lt;h3 id="header-guards">Header Guards&lt;/h3>
&lt;p>As you could see Includes are recursive this can lead to cycle includes.&lt;/p>
&lt;pre>&lt;code>cycleA.hpp
#include &amp;quot;cycleB.hpp&amp;quot;
cycleB.hpp
#include &amp;quot;cycleA.hpp&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>if we now compile this with (clang, gcc, msvc)&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /c /P cycleA.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang cycleA.hpp -E&amp;gt;cycleA.i
gcc cycleA.hpp -E&amp;gt;cycleA.i
&lt;/code>&lt;/pre>
&lt;p>Result will be:&lt;/p>
&lt;pre>&lt;code class="language-bash">user@MININT-DAH9RK3:/mnt/d/cpplecture$ clang cycleA.hpp -E&amp;gt;preprocessor.i
In file included from preprocessor/cycleA.hpp:1:
In file included from preprocessor/cycleB.hpp:1:
In file included from preprocessor/cycleA.hpp:1:
[edit by Simon replaced 200 more of `In file included from preprocessor/cycleA.hpp:1:` with this line]
preprocessor/cycleB.hpp:1:10: error: #include nested too deeply
#include &amp;quot;cycleA.hpp&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>if we add now a &lt;code>#pragma once&lt;/code> to &lt;code>cycleB.hpp&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-c">#pragma once
#include &amp;quot;cycleA.hpp&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>the compiler (clang, gcc, msvc) will run and spill out:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /c /P cycleA.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang cycleA.hpp -E&amp;gt;cycleA.i
gcc cycleA.hpp -E&amp;gt;cycleA.i
&lt;/code>&lt;/pre>
&lt;p>The result:&lt;/p>
&lt;pre>&lt;code class="language-c"># 1 &amp;quot;preprocessor/cycleA.hpp&amp;quot;
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 1
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 3
# 383 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 3
# 1 &amp;quot;&amp;lt;command line&amp;gt;&amp;quot; 1
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 2
# 1 &amp;quot;preprocessor/cycleA.hpp&amp;quot; 2
# 1 &amp;quot;preprocessor/cycleB.hpp&amp;quot; 1
# 1 &amp;quot;preprocessor/cycleA.hpp&amp;quot; 1
# 2 &amp;quot;preprocessor/cycleB.hpp&amp;quot; 2
# 1 &amp;quot;preprocessor/cycleA.hpp&amp;quot; 2
&lt;/code>&lt;/pre>
&lt;h2 id="compile-a-source-file">Compile a source file&lt;/h2>
&lt;p>The basic source file:&lt;/p>
&lt;pre>&lt;code class="language-c++">int main(){}
&lt;/code>&lt;/pre>
&lt;p>Invoke the compiler:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /c empty.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang -c empty.cpp
gcc -c empty.cpp
&lt;/code>&lt;/pre>
&lt;p>This generates a object file. &lt;code>.obj&lt;/code> or &lt;code>.o&lt;/code> on linux.&lt;/p>
&lt;h2 id="assembler">Assembler&lt;/h2>
&lt;p>This way we skipped one step: The assembler! This is the step in which the compiler creates a assembly representation for your target platform!&lt;/p>
&lt;p>To get the output that is used to generate the Object File you must tell the compiler to generate the assemble output for you:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /FAs /c empty.cpp
&lt;/code>&lt;/pre>
&lt;p>This will produce as &lt;code>.asm&lt;/code> file with your assembly&lt;/p>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang -S
&lt;/code>&lt;/pre>
&lt;p>This will produce a &lt;code>.s&lt;/code> file with your assembly.&lt;/p>
&lt;h3 id="inspecting-a-object-file">Inspecting a object file&lt;/h3>
&lt;p>Normally the compiler does the assembler step automatically and generates the object file. A object file contains all important information about the current translation unit. The most important question is: Which external objects are references? This is important since a TU does not know anything about other TU&amp;rsquo;s! The linker needs this information later to stitch the program together!&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> A Object file is on windows and Linux Systems different. Since on Windows it is a COFF generated by Microsoft C compiler and on Linux ELF/DWARF.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/COFF">https://en.wikipedia.org/wiki/COFF&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>We can view a Object file with:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;p>More infos: &lt;a href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-options?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-options?view=msvc-170&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-bash">DUMPBIN.EXE /ALL empty.obj
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-bash">objectdump -a empty.o
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> There could be a entire lecture about this! &lt;a href="https://www.youtube.com/watch?v=a5L66zguFe4">https://www.youtube.com/watch?v=a5L66zguFe4&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="linker">Linker&lt;/h2>
&lt;p>In this stage of the process multiple object files will be combined to a executable!&lt;/p>
&lt;h3 id="executable">Executable&lt;/h3>
&lt;p>Lets build a game:&lt;/p>
&lt;pre>&lt;code>/game/main.cpp
/lib/engine.hpp
/lib/engine.cpp
main.cpp
#include &amp;quot;engine.hpp&amp;quot;
int main(){
engine{create()};
}
engine.hpp
struct engine{
// stuff
};
[[nodiscard]] engine create() noexcept;
engine.cpp
#include &amp;quot;engine.hpp&amp;quot;
[[nodiscard]] engine create() noexcept{
return {};
}
&lt;/code>&lt;/pre>
&lt;p>Let us compile the game:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-bash">cd /game
cl.exe \c main.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cd /game
clang -c main.cpp -std=c++17
gcc -c main.cpp -std=c++17
&lt;/code>&lt;/pre>
&lt;p>This will spill out a compile error!&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; cl.exe /c main.cpp
Microsoft (R) C/C++ Optimizing Compiler Version 19.29.30136 for x86
Copyright (C) Microsoft Corporation. All rights reserved.
main.cpp
main.cpp(1): fatal error C1083: Cannot open include file: 'engine.hpp': No such file or directory
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> On Linux we will have the same result!&lt;/p>
&lt;/blockquote>
&lt;p>We need to tell the compiler where the header file is! &lt;code>/I[..]&lt;/code> or &lt;code>-I[..]&lt;/code>&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; cl.exe /c main.cpp /I ../lib
&lt;/code>&lt;/pre>
&lt;p>This works! we have a obj file!&lt;/p>
&lt;p>Let us investigate what is in the object file: We run &lt;code>DUMPBIN.EXE /ALL main.obj&lt;/code>&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; DUMPBIN.EXE /ALL main.obj
Microsoft (R) COFF/PE Dumper Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file main.obj
File Type: COFF OBJECT
FILE HEADER VALUES
14C machine (x86)
4 number of sections
61A8E6C9 time date stamp Thu Dec 2 16:31:21 2021
193 file pointer to symbol table
D number of symbols
0 size of optional header
0 characteristics
SECTION HEADER #1
.drectve name
0 physical address
0 virtual address
2F size of raw data
B4 file pointer to raw data (000000B4 to 000000E2)
0 file pointer to relocation table
0 file pointer to line numbers
0 number of relocations
0 number of line numbers
100A00 flags
Info
Remove
1 byte align
RAW DATA #1
00000000: 20 20 20 2F 44 45 46 41 55 4C 54 4C 49 42 3A 22 /DEFAULTLIB:&amp;quot;
00000010: 4C 49 42 43 4D 54 22 20 2F 44 45 46 41 55 4C 54 LIBCMT&amp;quot; /DEFAULT
00000020: 4C 49 42 3A 22 4F 4C 44 4E 41 4D 45 53 22 20 LIB:&amp;quot;OLDNAMES&amp;quot;
Linker Directives
-----------------
/DEFAULTLIB:LIBCMT
/DEFAULTLIB:OLDNAMES
SECTION HEADER #2
.debug$S name
0 physical address
0 virtual address
74 size of raw data
E3 file pointer to raw data (000000E3 to 00000156)
0 file pointer to relocation table
0 file pointer to line numbers
0 number of relocations
0 number of line numbers
42100040 flags
Initialized Data
Discardable
1 byte align
Read Only
RAW DATA #2
00000000: 04 00 00 00 F1 00 00 00 67 00 00 00 29 00 01 11 ....ñ...g...)...
00000010: 00 00 00 00 44 3A 5C 63 70 70 6C 65 63 74 75 72 ....D:\cpplectur
00000020: 65 5C 6C 69 6E 6B 65 72 5C 67 61 6D 65 5C 6D 61 e\linker\game\ma
00000030: 69 6E 2E 6F 62 6A 00 3A 00 3C 11 01 22 00 00 07 in.obj.:.&amp;lt;..&amp;quot;...
00000040: 00 13 00 1D 00 B8 75 00 00 13 00 1D 00 B8 75 00 .....¸u......¸u.
00000050: 00 4D 69 63 72 6F 73 6F 66 74 20 28 52 29 20 4F .Microsoft (R) O
00000060: 70 74 69 6D 69 7A 69 6E 67 20 43 6F 6D 70 69 6C ptimizing Compil
00000070: 65 72 00 00 er..
SECTION HEADER #3
.text$mn name
0 physical address
0 virtual address
12 size of raw data
157 file pointer to raw data (00000157 to 00000168)
169 file pointer to relocation table
0 file pointer to line numbers
1 number of relocations
0 number of line numbers
60500020 flags
Code
16 byte align
Execute Read
RAW DATA #3
00000000: 55 8B EC 51 E8 00 00 00 00 88 45 FF 33 C0 8B E5 U.ìQè.....Eÿ3À.å
00000010: 5D C3 ]Ã
RELOCATIONS #3
Symbol Symbol
Offset Type Applied To Index Name
-------- ---------------- ----------------- -------- ------
00000005 REL32 00000000 9 ?create@@YA?AUengine@@XZ (struct engine __cdecl create(void))
SECTION HEADER #4
.chks64 name
0 physical address
0 virtual address
20 size of raw data
173 file pointer to raw data (00000173 to 00000192)
0 file pointer to relocation table
0 file pointer to line numbers
0 number of relocations
0 number of line numbers
A00 flags
Info
Remove
(no align specified)
RAW DATA #4
00000000: 23 07 66 15 27 1A BF 1A FD FD 6A 15 8D E6 A5 E2 #.f.'.¿.ýýj..æ¥â
00000010: 42 E8 D5 96 AB C2 64 E1 00 00 00 00 00 00 00 00 BèÕ.«Âdá........
COFF SYMBOL TABLE
000 010575B8 ABS notype Static | @comp.id
001 80010191 ABS notype Static | @feat.00
002 00000002 ABS notype Static | @vol.md
003 00000000 SECT1 notype Static | .drectve
Section length 2F, #relocs 0, #linenums 0, checksum 0
005 00000000 SECT2 notype Static | .debug$S
Section length 74, #relocs 0, #linenums 0, checksum 0
007 00000000 SECT3 notype Static | .text$mn
Section length 12, #relocs 1, #linenums 0, checksum 6BED4AA5
009 00000000 UNDEF notype () External | ?create@@YA?AUengine@@XZ (struct engine __cdecl create(void))
00A 00000000 SECT3 notype () External | _main
00B 00000000 SECT4 notype Static | .chks64
Section length 20, #relocs 0, #linenums 0, checksum 0
String Table Size = 0x1D bytes
Summary
20 .chks64
74 .debug$S
2F .drectve
12 .text$mn
&lt;/code>&lt;/pre>
&lt;p>Under &lt;code>RELOCATIONS #3&lt;/code> we find something intersting:&lt;/p>
&lt;pre>&lt;code> Symbol Symbol
Offset Type Applied To Index Name
00000005 REL32 00000000 9 ?create@@YA?AUengine@@XZ (struct engine __cdecl create(void))
&lt;/code>&lt;/pre>
&lt;p>This somehow looks like: &lt;code>[[nodiscard ]] engine create() noexcept&lt;/code>. That is correct! In C++ we mangle names we (the compiler) renames the name after they implementation defined scheme (yes clang uses a different method than msvc! GREAT!)&lt;/p>
&lt;blockquote>
&lt;p>The reason for this is that we can have overloads (in short!) more infos here &lt;a href="https://www.geeksforgeeks.org/extern-c-in-c/">https://www.geeksforgeeks.org/extern-c-in-c/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>This means the compiler stores in the object file all sorts of interesting information about this TU (translation unit). In this case the compiler stores that at a offset of 5 the symbol &lt;code>?create@@YA?AUengine@@XZ (struct engine __cdecl create(void))&lt;/code> needs to be relocated! Relocated means that it can be found external!&lt;/p>
&lt;p>Enough of this inspection lets us create our executable!&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; link.exe main.obj
&lt;/code>&lt;/pre>
&lt;p>This also leads to a error!&lt;/p>
&lt;pre>&lt;code class="language-cpp">Microsoft (R) Incremental Linker Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
main.obj : error LNK2019: unresolved external symbol &amp;quot;struct engine __cdecl create(void)&amp;quot; (?create@@YA?AUengine@@XZ) referenced in function _main
main.exe : fatal error LNK1120: 1 unresolved externals
&lt;/code>&lt;/pre>
&lt;p>Do we remember:&lt;/p>
&lt;blockquote>
&lt;p>This means the compiler stores in the object file all sorts of interesting information about this TU (translation unit). In this case the compiler stores that at a offset of 5 the symbol &lt;code>?create@@YA?AUengine@@XZ (struct engine __cdecl create(void))&lt;/code> needs to be relocated! Relocated means that it can be found external!&lt;/p>
&lt;/blockquote>
&lt;p>This is what it means in practice! Oh right we did not compile &lt;code>lib/engine.cpp&lt;/code> Let us fix this!&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; cd ..
PS D:\cpplecture\linker&amp;gt; cd lib
PS D:\cpplecture\linker\lib&amp;gt; cl.exe /c engine.cpp
&lt;/code>&lt;/pre>
&lt;p>Now we have a &lt;code>lib/engine.obj&lt;/code>&lt;/p>
&lt;p>cool lets go back to our game and try again!&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; link.exe main.obj
Microsoft (R) Incremental Linker Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
main.obj : error LNK2019: unresolved external symbol &amp;quot;struct engine __cdecl create(void)&amp;quot; (?create@@YA?AUengine@@XZ) referenced in function _main
main.exe : fatal error LNK1120: 1 unresolved externals
&lt;/code>&lt;/pre>
&lt;p>We get the same error! But we compiled the other thing&amp;hellip;&lt;/p>
&lt;p>This time we have to remmeber:&lt;/p>
&lt;blockquote>
&lt;p>Translation Units are looked at individually and main.obj does not know anything of engine.obj!&lt;/p>
&lt;/blockquote>
&lt;p>This means we need to tell the linker &lt;strong>where&lt;/strong> our external symbols are living!&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; link.exe main.obj ../lib/engine.obj
&lt;/code>&lt;/pre>
&lt;p>This works we get out executable!&lt;/p>
&lt;h3 id="library">Library&lt;/h3>
&lt;p>In reality projects are really big and sometimes we split them into libraries. In general a library is nothing else than a collection of object files the linker can use statically or dynamically!&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> This overview will not touch the dynamic approach since this is a huge topic on its own!&lt;/p>
&lt;/blockquote>
&lt;p>Lets upgrade our &amp;ldquo;engine&amp;rdquo; example a bit:&lt;/p>
&lt;pre>&lt;code>engine.hpp
#pragma once
using cstring = const char*;
template&amp;lt;typename T&amp;gt;
struct container_t{
T* items;
unsigned int num_items;
unsigned int capacity;
};
struct entity_t {
unsigned int id;
};
struct world_t{
container_t&amp;lt;entity_t&amp;gt; entities;
};
struct engine_t{
void update(double dt);
entity_t spawn();
world_t world;
};
[[nodiscard ]] engine_t create() noexcept;
#include &amp;quot;engine.hpp&amp;quot;
[[nodiscard]] engine_t create() noexcept{
engine_t e{};
e.world.entities.items = new entity_t[100];
e.world.entities.capacity = 100;
return e;
}
entity_t engine_t::spawn(){
if(world.entities.num_items == world.entities.capacity){
// magic
}else{
world.entities.items[world.entities.num_items] = {world.entities.num_items};
}
return {world.entities.num_items};
}
void engine_t::update(double dt){
//...
}
&lt;/code>&lt;/pre>
&lt;p>Let us add a json parser &amp;hellip; every good C++ project needs one!&lt;/p>
&lt;pre>&lt;code>json.hpp
#pragma once
using cstring = const char*;
struct string_view{
cstring data_ptr;
unsigned int len;
};
struct json{
//..
};
struct json_object{
//..
};
struct json_array{
json_object* objects;
unsigned int len;
};
[[nodiscard]] json parse(cstring path) noexcept;
[[nodiscard]] json_object get_object(const json&amp;amp; root,cstring key) noexcept;
[[nodiscard]] json_array get_array(const json&amp;amp; root,cstring key) noexcept;
[[nodiscard]] string_view get_string(const json&amp;amp; root,cstring key) noexcept;
[[nodiscard]] double get_number(const json&amp;amp; root,cstring key) noexcept;
#include &amp;quot;json.hpp&amp;quot;
[[nodiscard]] json parse(cstring path) noexcept{
return {};
}
[[nodiscard]] json_object get_object(const json&amp;amp; root,cstring key) noexcept{
return {};
}
[[nodiscard]] json_array get_array(const json&amp;amp; root,cstring key) noexcept{
return {};
}
[[nodiscard]] string_view get_string(const json&amp;amp; root,cstring key) noexcept{
return {};
}
[[nodiscard]] double get_number(const json&amp;amp; root,cstring key) noexcept{
return {};
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>The game:&lt;/strong>&lt;/p>
&lt;pre>&lt;code>level.hpp
#include &amp;quot;engine.hpp&amp;quot;
struct level{
world_t world;
};
void load(engine_t&amp;amp; engine, cstring level) noexcept;
level.cpp
#include &amp;quot;engine.hpp&amp;quot;
#include &amp;quot;json.hpp&amp;quot;
void load(engine_t&amp;amp; engine, cstring level) noexcept{
json l{parse(level)};
}
main.cpp
#include &amp;quot;engine.hpp&amp;quot;
#include &amp;quot;level.hpp&amp;quot;
int main(){
engine_t core{create()};
load(core,&amp;quot;Test_level.json&amp;quot;);
}
&lt;/code>&lt;/pre>
&lt;p>Let us build a &lt;code>.lib&lt;/code> or &lt;code>.a&lt;/code> file.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note&lt;/strong>: again a static lib is nothing else than a collection (or archive) or object files. This is why the name on Linux is .a which stands for &lt;em>archive&lt;/em> and the tool on Linux for creating one is called &lt;code>ar&lt;/code> &lt;a href="https://linux.die.net/man/1/ar">https://linux.die.net/man/1/ar&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>At first we need to compile both of our translation units (source files):&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cd lib
PS D:\cpplecture\linker\lib&amp;gt; cl.exe /c engine.cpp json.cpp
--&amp;gt; engine.obj
--&amp;gt; json.obj
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang -c engine.cpp json.cpp -std=c++17
gcc -c engine.cpp json.cpp -std=c++17
--&amp;gt; json.o
--&amp;gt; engine.o
&lt;/code>&lt;/pre>
&lt;p>Now we need to stich those object files together this can be done via the &lt;code>lib.exe&lt;/code> or the &lt;code>ar&lt;/code> tool on linux:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>lib.exe .\json.obj .\engine.obj /out:engine.lib
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;a href="https://docs.microsoft.com/en-us/cpp/build/reference/overview-of-lib?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/reference/overview-of-lib?view=msvc-170&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>ar rc engine.a json.o engine.o
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;a href="https://llvm.org/docs/CommandGuide/llvm-ar.html">https://llvm.org/docs/CommandGuide/llvm-ar.html&lt;/a> or &lt;a href="https://linux.die.net/man/1/ar">https://linux.die.net/man/1/ar&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Now we have a lib: &lt;code>engine.lib&lt;/code> or &lt;code>engine.a&lt;/code> and we can now link against this with &lt;code>ld&lt;/code> (on Linux) or &lt;code>link.exe&lt;/code> on windows just like we were to link object files:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code> cl.exe main.cpp level.cpp /c /I ../lib
link.exe .\main.obj .\level.obj ../lib/engine.lib /out:game.exe
--&amp;gt; game.exe
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang main.cpp level.cpp -c -I ../lib
ld .\main.o .\level.o ../lib/engine.a -o game
--&amp;gt; game
&lt;/code>&lt;/pre>
&lt;h2 id="extra">Extra&lt;/h2>
&lt;p>If we now inspect the &lt;code>engine.obj&lt;/code>&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; DUMPBIN.EXE /RELOCATIONS engine.lib
Microsoft (R) COFF/PE Dumper Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file engine.lib
File Type: LIBRARY
RELOCATIONS #3
Symbol Symbol
Offset Type Applied To Index Name
-------- ---------------- ----------------- -------- ------
00000077 REL32 00000000 9 ??_U@YAPAXI@Z (void * __cdecl operator new[](unsigned int))
&lt;/code>&lt;/pre>
&lt;p>and for &lt;code>main.obj&lt;/code>&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; DUMPBIN.EXE /RELOCATIONS main.obj
Microsoft (R) COFF/PE Dumper Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file main.obj
File Type: COFF OBJECT
RELOCATIONS #4
Symbol Symbol
Offset Type Applied To Index Name
-------- ---------------- ----------------- -------- ------
0000000B REL32 00000000 C ?create@@YA?AUengine_t@@XZ (struct engine_t __cdecl create(void))
00000036 DIR32 00000000 9 $SG2851
0000003F REL32 00000000 D ?load@@YAXAAUengine_t@@PBD@Z (void __cdecl load(struct engine_t &amp;amp;,char const *))
&lt;/code>&lt;/pre>
&lt;p>We have 3:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Symbol&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>?create@@YA?AUengine_t@@XZ (struct engine_t __cdecl create(void))&lt;/code>&lt;/td>
&lt;td>&lt;code>[[nodiscard]] engine_t create() noexcept&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$SG2851&lt;/td>
&lt;td>dunno&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>?load@@YAXAAUengine_t@@PBD@Z (void __cdecl load(struct engine_t &amp;amp;,char const *))&lt;/code>&lt;/td>
&lt;td>&lt;code>void load(engine_t&amp;amp; engine, cstring level) noexcept&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>If we now look at what symbols we can find in &lt;code>engine.lib&lt;/code>:&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; DUMPBIN.EXE /SYMBOLS engine.lib
Microsoft (R) COFF/PE Dumper Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file engine.lib
File Type: LIBRARY
COFF SYMBOL TABLE
000 010575B8 ABS notype Static | @comp.id
001 80010191 ABS notype Static | @feat.00
002 00000002 ABS notype Static | @vol.md
003 00000000 SECT1 notype Static | .drectve
Section length 2F, #relocs 0, #linenums 0, checksum 0
005 00000000 SECT2 notype Static | .debug$S
Section length 78, #relocs 0, #linenums 0, checksum 0
007 00000000 SECT3 notype Static | .text$mn
Section length A9, #relocs 1, #linenums 0, checksum 47C05A6
009 00000000 UNDEF notype () External | ??_U@YAPAXI@Z (void * __cdecl operator new[](unsigned int))
00A 00000000 SECT3 notype () External | ?update@engine_t@@QAEXN@Z (public: void __thiscall engine_t::update(double))
00B 00000010 SECT3 notype () External | ?spawn@engine_t@@QAE?AUentity_t@@XZ (public: struct entity_t __thiscall engine_t::spawn(void))
00C 00000060 SECT3 notype () External | ?create@@YA?AUengine_t@@XZ (struct engine_t __cdecl create(void))
00D 00000000 SECT4 notype Static | .chks64
Section length 20, #relocs 0, #linenums 0, checksum 0
String Table Size = 0x6B bytes
COFF SYMBOL TABLE
000 010575B8 ABS notype Static | @comp.id
001 80010191 ABS notype Static | @feat.00
002 00000002 ABS notype Static | @vol.md
003 00000000 SECT1 notype Static | .drectve
Section length 2F, #relocs 0, #linenums 0, checksum 0
005 00000000 SECT2 notype Static | .debug$S
Section length 74, #relocs 0, #linenums 0, checksum 0
007 00000000 SECT3 notype Static | .text$mn
Section length 67, #relocs 0, #linenums 0, checksum 789BEE7A
009 00000000 SECT3 notype () External | ?parse@@YA?AUjson@@PBD@Z (struct json __cdecl parse(char const *))
00A 00000010 SECT3 notype () External | ?get_object@@YA?AUjson_object@@ABUjson@@PBD@Z (struct json_object __cdecl get_object(struct json const &amp;amp;,char const *))
00B 00000020 SECT3 notype () External | ?get_array@@YA?AUjson_array@@ABUjson@@PBD@Z (struct json_array __cdecl get_array(struct json const &amp;amp;,char const *))
00C 00000040 SECT3 notype () External | ?get_string@@YA?AUstring_view@@ABUjson@@PBD@Z (struct string_view __cdecl get_string(struct json const &amp;amp;,char const *))
00D 00000060 SECT3 notype () External | ?get_number@@YANABUjson@@PBD@Z (double __cdecl get_number(struct json const &amp;amp;,char const *))
00E 00000000 UNDEF notype External | __fltused
00F 00000000 SECT4 notype Static | .rdata
Section length 8, #relocs 0, #linenums 0, checksum 0, selection 2 (pick any)
011 00000000 SECT4 notype External | __real@0000000000000000
012 00000000 SECT5 notype Static | .chks64
Section length 28, #relocs 0, #linenums 0, checksum 0
String Table Size = 0xE6 bytes
&lt;/code>&lt;/pre>
&lt;p>We get the list of all symbols in both object files: &lt;code>engine.obj&lt;/code> and &lt;code>json.obj&lt;/code>&lt;/p>
&lt;h2 id="references">References:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/cpp/build/reference/overview-of-lib?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/reference/overview-of-lib?view=msvc-170&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://llvm.org/docs/CommandGuide/llvm-ar.html">https://llvm.org/docs/CommandGuide/llvm-ar.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mottosso.gitbooks.io/clang/content/building_a_static_library.html">https://mottosso.gitbooks.io/clang/content/building_a_static_library.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gist.github.com/jsanchezuy/23b1fc8c592455f1bb84">https://gist.github.com/jsanchezuy/23b1fc8c592455f1bb84&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/objdump.1.html">https://man7.org/linux/man-pages/man1/objdump.1.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.computerhope.com/unix/uld.htm">https://www.computerhope.com/unix/uld.htm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options?view=msvc-170&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://linux.die.net/man/1/ar">https://linux.die.net/man/1/ar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.cppreference.com/w/cpp/language/translation_phases">https://en.cppreference.com/w/cpp/language/translation_phases&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/COFF">https://en.wikipedia.org/wiki/COFF&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-options?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-options?view=msvc-170&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=a5L66zguFe4">https://www.youtube.com/watch?v=a5L66zguFe4&lt;/a> (CppCon 2017: Michael Spencer “My Little Object File: How Linkers Implement C++”)&lt;/li>
&lt;li>&lt;a href="https://www.geeksforgeeks.org/extern-c-in-c/">https://www.geeksforgeeks.org/extern-c-in-c/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ibm.com/docs/en/i/7.2?topic=linkage-name-mangling-c-only">https://www.ibm.com/docs/en/i/7.2?topic=linkage-name-mangling-c-only&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://web.mit.edu/tibbetts/Public/inside-c/www/mangling.html">http://web.mit.edu/tibbetts/Public/inside-c/www/mangling.html&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>