<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp | Simon Renger</title><link>/tags/cpp/</link><atom:link href="/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><description>cpp</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Simon Renger 2022</copyright><lastBuildDate>Wed, 22 Jun 2022 00:00:00 +0100</lastBuildDate><image><url>/img/icon-192.png</url><title>cpp</title><link>/tags/cpp/</link></image><item><title>How could an embeddable visual scripting language look like?</title><link>/posts/how_could_an_embeddable_visual_scripting_language_look_like/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0100</pubDate><guid>/posts/how_could_an_embeddable_visual_scripting_language_look_like/</guid><description>&lt;p>Once, during my work on the &lt;em>sadly never published&lt;/em> game Reptoads – a round-based deterministic multiplayer cooperative card game, I got asked by different members of the art and design team: why can’t we have a visual scripting language such as Blueprints or Shader Graph for either the gameplay code or the visuals? My answer was always the same: we don’t have enough time to implement such a tool. This question, however, got stuck in my mind and I started searching for a “Lua” of the visual scripting languages just to find&amp;hellip; nothing. Roughly three years later, the same question kept coming up in different projects, while my answer and my research results stayed the same. This made me curious, &lt;em>why is there no such thing as an embeddable visual scripting language that can be used?&lt;/em>&lt;/p>
&lt;p>Asking myself why is there no such language and how would one look like, led me to write my Master thesis with the title: &lt;a href="https://linktr.ee/simonrenger">“Investigation into the criteria of embeddability of visual scripting languages within the domain of game development”&lt;/a>. In my research paper I composed a list of potential criteria that classify a visual scripting language (VSL) as embeddable. In this article I will go through these criteria and design a hypothetical embeddable VSL, which I called &lt;a href="https://simonrenger.github.io/noodle/">Noodle&lt;/a>. This will be Part 1 of a series of articles focused on creating a usable VSL prototype.&lt;/p>
&lt;p>You might think now: &lt;em>hold on for a second! Aren’t there lots of tools doing similar things? Do we &lt;strong>really&lt;/strong> need to reinvent the wheel?&lt;/em>&lt;/p>
&lt;p>Yes, your instinct is right, there are some well-known solutions out there like Unreal Engine’s Blueprints or Unity’s Visual Scripting, but you simply cannot take their scripting runtime out and put this into your specific 3D retro shooter game engine. Now you might want to say: &lt;em>okay then, I will just use scripting, there are a lot of scripting languages out there (Lua, luau, wren, daScript, anglescript etc.)&lt;/em>. That argument is also valid but what happens when you look for a designer to help you with your indie game and all you can find are designers that have only worked with Unity or Unreal before. In those cases, it would be better to tell them that there is a language that works like Blueprints or is less complicated than C#, especially since it is easier to learn a VSL than a normal scripting language, as literature suggests [1]–[3].&lt;/p>
&lt;h2 id="some-thoughts-about-visual-scripting">Some thoughts about visual scripting&lt;/h2>
&lt;p>First of all, I need to acknowledge that visual scripting is not the silver bullet for all problems in game development and often does more harm than good, especially when it comes to performance and maintainability (&lt;a href="https://80.lv/articles/blueprints-from-hell-share-the-horror/">Blueprints from Hell: Share The Horror&lt;/a>). I want to stress that this article is not pro or against visual scripting languages but rather sees it as a tool, just as with any other programming language (yes, a VSL is a programming language). Of course, there might be other tools out there that do a specific job better but it always depends on the use case and the requirements. During my Masters in Game Technology, I had the chance to interview industry professionals and one of my participants emphasized that the requirements of the game are the most important factor when deciding what tech to choose when working on a game.&lt;/p>
&lt;p>Another aspect to consider is what are we intending to use the visual scripting language for. During my research, all my interviewees stated that they see the benefits of a VSL in being able to quickly prototype features and its quick iteration times overall. Also, a VSL is perfectly made for certain tasks such as processing sequences. While for others it might be not the right tool such as performance-critical code passes, unless the graph is compiled to native code and heavily optimized. Moreover, VSLs are used for gluing systems together, as industry experts and literature suggest [$$]. In addition, VSLs are often used to handle UI events, for example in the UI workflow, but also for the game logic in general. They are also used as a domain specific language for workflows such as Shader / Material editing or state machines.&lt;/p>
&lt;p>All these different aspects of possible use cases make it quite difficult to define the best-fit solution. Since it is not easy to determine the right requirements for each of those fields, the idea is to create a generalized model of a language that can be used for these different aspects. I am fully aware that this might not be the ultimate solution that fits all cases.&lt;/p>
&lt;h2 id="the-basic-language-concepts">The basic language concepts&lt;/h2>
&lt;p>I will discuss the core concepts of Noodle by following the result structure of my paper. My paper found five major aspects that are potentially important when designing a language framework with embeddability in mind. My thesis defines them as follows: 1.&lt;em>performance and the identified subcategories, 2.mechanical aspects of embedding software and their respective subcategories, 3.license, 4.documentation, 5.tooling and workflow&lt;/em>*.* While we look into each of these aspects, we define what consequences it has for Noodle.&lt;/p>
&lt;p>&lt;strong>General design overview&lt;/strong>&lt;/p>
&lt;p>Before we dive deep into these findings, I will briefly describe the main characteristics of Noodle. Noodle will be diagram-based [1], [4] which means that the language is graph-based and the execution can be followed by traversing nodes. As my research shows, this is the most commonly used VSL form in game engines, e.g., in Unreal Engine, Unity and Godot [5]–[8]. A popular alternative is the block-based design. A block-based design is used for Scratch and Google’s Blockly [9]–[11] but it is not often used in games. Moreover, Noodle will offer pure nodes, nodes without side effects and nodes that may have side effects [12]. They are differently identified by either having an “execution” wire/connection or just a data flow connection. This allows the dialect designer to decide if they need support for one of these concepts or both, depending on the use case requirements. On its own, the language is not event-based, so a graph can be triggered at any node at any point in time by the runtime. However, the dialect designer can specify nodes that can be triggered. These nodes can be used as entry points which would allow an event-based structure if needed. All these decisions are based on what is common in tools used in the game industry, be it Godot’s visual scripting or Unreal Engine’s Material Editor [8], [13]–[17].&lt;/p>
&lt;p>Noodle’s design idea of being a composable language that one can shape depending on the users’ needs, or how literature would call it “extending” by being an extension language, is greatly inspired by the works of Hisham Muhammad and Roberto Ierusalimschy in their paper about the used API design of the &lt;a href="https://www.lua.org/">Lua programming language&lt;/a> [18]–[21]. Since we are talking about a visual scripting language which logic is expressed in composing visual elements [22], we need some form of specification. In Noodle the dialect is described via a protocol: what nodes it supports, what kind of types are supported, etc. Moreover, Noodle supports internal modules, i.e., subgraphs that can help organizing your graph, as well as external modules, if a module resolve function is provided. If not, only internal modules will work. However, the defined protocol might differ from dialect to dialect, depending on the use of the language. We will talk about the protocol an its uses later.&lt;/p>
&lt;p>The next few paragraphs will now take the findings of my study and describe the impact they might have on Noodle.&lt;/p>
&lt;p>&lt;strong>Performance&lt;/strong>&lt;/p>
&lt;p>&lt;em>Development performance&lt;/em>
One of the most important factors for the game industry is the ability to perform quick iteration cycles and to be able to quickly prototype a feature [23, pp. 956–957] [20], [24]. Many interviewees have expressed the opinion that script hot reloading is a crucial feature they would expect from a VSL. It has been shown also in literature [23] that script hot reloading is a great feature, that supports quick iteration and rapid prototyping. Based on these observations, Noodle will support script hot reloading to empower users with quick prototyping.&lt;/p>
&lt;p>&lt;em>Runtime performance&lt;/em>
When talking to any game programmer, they will most likely make a similar statement as many of my study participants, that memory is the number one bottleneck in games. Although, it greatly depends on the requirements of the game and how dramatic the runtime performance is influenced by the right memory access patterns or the right allocation strategies. Therefore, it is not surprising that most of the participants expressed their opinions on how memory management should work. The major conclusion is that in a VSL, we know from early on what kind of data we will handle since all inputs and outputs of all nodes are known at translation time, therefore the graph could either allocate a large chunk of memory and manage that like in &lt;a href="https://www.fastly.com/blog/webassembly-memory-management-guide-for-c-rust-programmers">WebAssembly&lt;/a> where “&amp;hellip;opcodes accessing memory are not given addresses, but offsets relative to the beginning of a linear memory segment whose size is always known.” The memory model of Noodle will follow the same mentality and will at the beginning allocate the needed memory through a memory allocator interface that the user can modify, if needed. If memory needs to be accessed in a form of a pointer, Noodle will not be able to do anything with these pointers, so it will just pass them down to native functions that are able to understand them.&lt;/p>
&lt;p>When it comes to a scripting language and a VSL, which is nothing else than a subcategory [1], [25], the execution method is important. Robert Nystrom states in both of his books “Crafting interpreters” and “Game programming patterns” [26, p. 17], [27, pp. 155–179] that a tree-walking interpreter, a form of an interpreter that traverses the graph by recursively calling the nodes, is slower than compiling the graph down to bytecode that is executed in a virtual machine (VM) or transpiled to a different source code [26, pp. 16–20], [28], [27, pp. 155–179] ,[23, pp. 52,954-958]. Based on these findings, Noodle will compile to bytecode with the intention that the user can compile a Noodle graph representation to C and compile to native code depending on their platform as a last shipping step (if providing a backend). This transpiling or compiling to native code has been mentioned in the interviews as an important feature. It can also be considered to allow the language to enable hot patching of the native generated code. This means that if something is wrong with the compiled C code, a content update of a bytecode compiled graph can be used to hot patch this part of the code.&lt;/p>
&lt;p>&lt;strong>Mechanical aspects of embedding software&lt;/strong>&lt;/p>
&lt;p>&lt;em>API design&lt;/em>
As described in the above-mentioned papers from H.Muhammad and R.Ierusalimschy about the API design of Lua and other scripting languages such as Perl or Python, it can be concluded that an API should be flexible to provide the ability to extend the underlaying language not in a verbose (like Perl) manner, but more in a concise declarative manner. This view is supported by my interviewees who describe that an API should be able to bind, for example, an external editor but should also be small enough to be easily manageable. Moreover, academia as well as the interviewed industry professionals argue that the API should be written in the C programming language or at least provide C foreign function interface, since C is considered as the lingua franca of programming languages [18]–[21]. To provide maximal portability from an API point of view, the header files of Noodle will be written in C99 and the implementation will be done in C11.&lt;/p>
&lt;p>&lt;em>Dependencies&lt;/em>
The game industry is notorious for reinventing the wheel [29], [30] and this problem might stem from the platforms we are catering to and the software we are working with. Therefore, having many dependencies that we need to maintain and maybe port to different platforms is not desired. This is what my research suggests and what an industry professional states in an interview: “When you develop a commercial product, you also need to consider two things. Since dependencies might be taken offline at any time, it is very important to have your own copy of them. Also, for various certification on platforms you need to keep in mind that they perform security audits on those dependencies.”. These insights led to the decision for Noodle to have no external dependencies besides the OS dependencies on the platforms it supports.&lt;/p>
&lt;p>&lt;strong>License &amp;amp; documentation&lt;/strong>&lt;/p>
&lt;p>The game industry caters for many different platforms with different requirements, some are open source, some are not. Therefore, the license needs to be permissive since it is not always possible to open-source certain aspects of the entire codebase due to NDA regulations. This is the reason why Noodle will use the MIT license or the Apache License, Version 2.0, depending on the user’s need.&lt;/p>
&lt;p>Besides the license, a good documentation on how to embed the language into your game framework is needed. My thesis research has shown that it is expected by users for some form of online documentation and samples to exist. Therefore, Noodle should provide online documentation in form of a GitHub Page but also examples on how to bind the language.&lt;/p>
&lt;p>&lt;strong>Workflow &amp;amp; tools&lt;/strong>&lt;/p>
&lt;p>So far, none of the categories of embeddability are really different from what one would expect from a regular scripting language. In fact, what literature says is that they are nearly matching, and &lt;a href="https://softwareengineering.stackexchange.com/questions/403911/what-makes-a-scripting-language-embeddable">Software Engineering Stack Exchange&lt;/a> confirms it. The major difference explained in literature by B.Myers already in 1989 in “Taxonomies of Visual Programming” [1] and in the works of Nystrom and J.Gregory [23], [27], the biggest challenge for a VSL is the UI/UX aspect and mainly the visual scripting environment (VSE). A VSE can be seen as the integrated development environment (IDE) for VSLs. My thesis concluded that among all aspects, workflow and tooling are the most important.&lt;/p>
&lt;p>Unfortunately, there is not much existing research on what qualifies a good visual scripting environment within the domain of game development. If we look outside of the game industry, there are a few papers on this topic, but they mostly describe the design of visual scripting environments for block-based languages, since they are mainly used for educational purposes. Although the industry professionals participating in my study shared some important insights, proper academic research would be needed to make academic claims. However, for this prototype the statements of industry professionals and the scarce UI / UX research on visual scripting environments will base the foundation for Noodle’s UI / UX.&lt;/p>
&lt;p>The industry professionals stated that one cannot just use Notepad or Visual Studio to edit the “source code” of a VSL, therefore they would expect either a fully-fletched editor to come with the VSL or a flexible API to allow them to bind an editor themselves. One of the participants stated that they would use the provided editor to get acquainted with the language and then use the API to build their own that matches the paradigms and needs of their own ecosystem. Hence, Noodle will come with a prototype of an editor and a flexible API that allows the user to bind a custom editor.&lt;/p>
&lt;p>For the first prototype, the language will come with a Visual Studio Code extension that enables the editor to understand Noodle files, while the editor will communicate with the Noodle runtime via the WebSocket API by using the protocol described later. Whenever a change occurs in the editor, the updated graph will be sent to the runtime and the runtime user can decide if it is needed to recompile the current graph and swap it with the new changes. The goal is to provide an embeddable editor view written in C or C++ as an external tool on top of the Noodle APIs.&lt;/p>
&lt;p>The mentioned WebSocket-based API allows network communication to other software that might be the editor. The VS Code extension will be part of the first prototype to demonstrate this communication feature. A network-based communication might be more suitable for games that separate game runtime and editor runtime, while the API communication via the C interface might be better suited for custom game engines that have a built-in editor. Important to mention is that the WebSocket API is purely optional.&lt;/p>
&lt;p>Since debugging and visualizing what is happening within the VSL has been classified as very important, Noodle should come with an ability to attach a debugger to it. In the first prototype we can try to make use of the VS Code Debugger framework and provide the ability to connect to it.&lt;/p>
&lt;p>A Noodle document will be in JSON format that can be parsed with any JSON parser and can be checked in source control like a normal text file. The main reason why JSON has been chosen is that it provides a better source control management support. Also, it can be diffed without big issues, while for example a binary file format would cause source control issues (google ‘Blueprints and source control’).&lt;/p>
&lt;h2 id="the-noodle-protocol">The Noodle Protocol&lt;/h2>
&lt;p>As mentioned above, Noodle runs on a protocol that gives an overview of what nodes are available and what types can the runtime understand. This indicates that Noodle can be either statically or more dynamically typed, depending on the needs of the dialect designer. The Noodle protocol can be generated via the API and will return either a protocol struct that can be used via the C interface or a JSON representation that can be used otherwise in tools or in the WebSocket API.&lt;/p>
&lt;p>Besides the Noodle protocol that describes the language, there is the &lt;em>noodle file&lt;/em> or &lt;em>noodle document –&lt;/em> the script file. One can see the protocol like a header file in C or C++ and a noodle file as the source file. The noodle document describes the current file the VM is processing. As mentioned above, each noodle file may contain subgraphs (internal modules) or if enabled, external modules. In principle, every noodle document contains three regions:&lt;/p>
&lt;p>&lt;em>Protocol&lt;/em> – this region describes the meta data of the current language dialect. The VM will check this region and verify that the name of the dialect, as well as the version, are matching. If not, the file cannot be passed. Migration can be implemented with this approach.&lt;/p>
&lt;p>&lt;em>Graph&lt;/em> – this region describes the actual data of the graph, which includes the modules, nodes, connections, and the data.&lt;/p>
&lt;p>&lt;em>Editor&lt;/em> – implementation defined region that can be used to define editor specific data such as position of nodes, etc. This region is not used by the VM in any way.&lt;/p>
&lt;p>The &lt;em>graph&lt;/em> region is the only region where the VM interpreter needs to understand the data of the file, while the &lt;em>protocol&lt;/em> region is there to make sure that the noodle file matches this dialect.&lt;/p>
&lt;p>For more in depth information checkout the &lt;a href="https://simonrenger.github.io/noodle/lang/index.html">Noodle Language Specifications&lt;/a>&lt;/p>
&lt;h2 id="next-steps">Next steps&lt;/h2>
&lt;p>This article has described so far what one could expect from a visual scripting language to define the VM as potentially embeddable and has illustrated this by giving concrete examples per category on the prototype language Noodle. Along the series of articles, we will take this further and go through each step of implementing the language, which will function as practical application of my theoretical study.&lt;/p>
&lt;p>In the next article we will discuss the protocol and the document design a little bit more but will mainly focus on the API design and the editor implementation in VS code. This will also be the first practical test of the protocol and the API.&lt;/p>
&lt;p>For more information, follow me on Twitter: &lt;a href="https://twitter.com/kazum93">Kazum93&lt;/a> or check the &lt;a href="https://simonrenger.github.io/noodle/">Noodle page&lt;/a> on GitHub. Also, if you are interested in reading my research paper that I have been referring to all the time, you can find it on R&lt;a href="https://linktr.ee/simonrenger">esearchGate&lt;/a> or my &lt;a href="https://linktr.ee/simonrenger">website&lt;/a>.&lt;/p>
&lt;p>[1] B. A. Myers, “Taxonomies of Visual Programming,” 1989.&lt;/p>
&lt;p>[2] M. F. Msiska and L. Van Zijl, “From visual scripting to Lua,” &lt;em>ACM Int. Conf. Proceeding Ser.&lt;/em>, pp. 94–99, 2012, doi: 10.1145/2389836.2389848.&lt;/p>
&lt;p>[3] M. M. Burnett, “Visual object-oriented programming,” &lt;em>Proc. Conf. Object-Oriented Program. Syst. Lang. Appl. OOPSLA&lt;/em>, vol. Part F1296, no. April 1994, pp. 127–129, 1993, doi: 10.1145/260303.261240.&lt;/p>
&lt;p>[4] M. M. Burnett and M. J. Baker, “A Classification System for Visual Programming Languages,” &lt;em>J. Vis. Lang. Comput.&lt;/em>, vol. 5, no. 3, pp. 287–300, 1994, doi: &lt;a href="https://doi.org/10.1006/jvlc.1994.1015">https://doi.org/10.1006/jvlc.1994.1015&lt;/a>.&lt;/p>
&lt;p>[5] E. Games, “Blueprints,” 2021. &lt;a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/&lt;/a>&lt;/p>
&lt;p>[6] E. Games, “Kismet Visual Scripting.” &lt;a href="https://docs.unrealengine.com/udk/Three/KismetHome.html">https://docs.unrealengine.com/udk/Three/KismetHome.html&lt;/a>&lt;/p>
&lt;p>[7] Unity Technology, “Bolt Documentation.” &lt;a href="https://docs.unity3d.com/bolt/1.4/manual/index.html">https://docs.unity3d.com/bolt/1.4/manual/index.html&lt;/a>&lt;/p>
&lt;p>[8] G. Team, “Godot Visual Scripting.” &lt;a href="https://docs.godotengine.org/en/stable/getting_started/scripting/visual_script/getting_started.html">https://docs.godotengine.org/en/stable/getting_started/scripting/visual_script/getting_started.html&lt;/a>&lt;/p>
&lt;p>[9] Google, “Blocky.” &lt;a href="https://developers.google.com/blockly">https://developers.google.com/blockly&lt;/a> (accessed Apr. 14, 2022).&lt;/p>
&lt;p>[10] J. Maloney, M. Resnick, N. Rusk, B. Silverman, and E. Eastmond, “The scratch programming language and environment,” &lt;em>ACM Trans. Comput. Educ.&lt;/em>, vol. 10, no. 4, pp. 1–15, 2010, doi: 10.1145/1868358.1868363.&lt;/p>
&lt;p>[11] MIT, “Scratch.” &lt;a href="https://scratch.mit.edu/">https://scratch.mit.edu/&lt;/a>&lt;/p>
&lt;p>[12] P. Wadler, “The essence of functional ( Invited programming talk ) recursive a compiler language,” &lt;em>Proc. 19th ACM SIGPLANSIGACT Symp. Princ. Program. Lang.&lt;/em>, pp. 1–14, 1992.&lt;/p>
&lt;p>[13] G. Team, “VisualShaders.” &lt;a href="https://docs.godotengine.org/en/stable/tutorials/shading/visual_shaders.html">https://docs.godotengine.org/en/stable/tutorials/shading/visual_shaders.html&lt;/a>&lt;/p>
&lt;p>[14] “Unreal Engine 4 Material Editor.” &lt;a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Materials/Editor/">https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Materials/Editor/&lt;/a>&lt;/p>
&lt;p>[15] Unity Technology, “Shader Graph”, [Online]. Available: &lt;a href="https://unity.com/shader-graph">https://unity.com/shader-graph&lt;/a>&lt;/p>
&lt;p>[16] M. Autodesk, “Maya Node Editor.” [Online]. Available: &lt;a href="https://knowledge.autodesk.com/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2019/ENU/Maya-Basics/files/GUID-23277302-6665-465F-8579-9BC734228F69-htm.html">https://knowledge.autodesk.com/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2019/ENU/Maya-Basics/files/GUID-23277302-6665-465F-8579-9BC734228F69-htm.html&lt;/a>&lt;/p>
&lt;p>[17] B. F. Blender 3D, “Shader Editor.” &lt;a href="https://docs.blender.org/manual/en/latest/editors/shader_editor.html">https://docs.blender.org/manual/en/latest/editors/shader_editor.html&lt;/a>&lt;/p>
&lt;p>[18] H. Muhammad and R. Ierusalimschy, “C APIs in extension and extensible languages,” &lt;em>J. Univers. Comput. Sci.&lt;/em>, vol. 13, no. 6, pp. 839–853, 2007.&lt;/p>
&lt;p>[19] H. H. Muhammad, “A study on scripting language APIs,” 2006.&lt;/p>
&lt;p>[20] R. Ierusalimschy, L. H. De Figueiredo, and W. C. Filho, “SPE paper Lua – an extensible extension language,” vol. 6, no. 1996, pp. 635–652, 2015.&lt;/p>
&lt;p>[21] R. Ierusalimschy, L. De Figueiredo, and W. Celes, “The evolution of an extension language: A history of Lua,” &lt;em>Proc. V Brazilian Symp. Program. Lang.&lt;/em>, vol. 1, no. 1, pp. 1–16, 2001, [Online]. Available: &lt;a href="http://www.lua.org/history.html%0Ahttp://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.15.9210&amp;amp;rep=rep1&amp;amp;type=pdf">http://www.lua.org/history.html%0Ahttp://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.15.9210&amp;amp;rep=rep1&amp;amp;type=pdf&lt;/a>&lt;/p>
&lt;p>[22] M. Idrees, F. Aslam, K. Shahzad, and S. M. Sarwar, “Towards a Universal Framework for Visual Programming Languages,” &lt;em>Pak. J. Engg. Appl. Sci.&lt;/em>, vol. 23, no. July, pp. 55–65, 2018, [Online]. Available: &lt;a href="https://www.researchgate.net/publication/328191862_Towards_a_Universal_Framework_for_Visual_Programming_Languages">https://www.researchgate.net/publication/328191862_Towards_a_Universal_Framework_for_Visual_Programming_Languages&lt;/a>&lt;/p>
&lt;p>[23] J. Gregory, &lt;em>Game Engine Architecture, Second Edition&lt;/em>, 2nd ed. USA: A. K. Peters, Ltd., 2014.&lt;/p>
&lt;p>[24] R. Ierusalimschy, L. H. de Figueiredo, and W. Celes, “Passing a Language through the Eye of a Needle,” &lt;em>Queue&lt;/em>, vol. 9, no. 5, pp. 20–29, 2011, doi: 10.1145/1978862.1983083.&lt;/p>
&lt;p>[25] J. K. Ousterhout, “Scripting: Higher-level programming for the 21st century,” &lt;em>Computer (Long. Beach. Calif).&lt;/em>, vol. 31, no. 3, pp. 23–30, 1998, doi: 10.1109/2.660187.&lt;/p>
&lt;p>[26] R. Nystrom, &lt;em>Crafting Interpreters&lt;/em>, 1st ed. ‎ Genever Benning. [Online]. Available: &lt;a href="https://www.craftinginterpreters.com/">https://www.craftinginterpreters.com/&lt;/a>&lt;/p>
&lt;p>[27] R. Nystrom, “Game Programming Patterns,” in &lt;em>Game Programming Patterns&lt;/em>, Genever Benning, 2014. [Online]. Available: &lt;a href="https://books.google.nl/books?id=AnvVrQEACAAJ">https://books.google.nl/books?id=AnvVrQEACAAJ&lt;/a>&lt;/p>
&lt;p>[28] R. Nystrom, “A Virtual Machine,” 2021. &lt;a href="https://craftinginterpreters.com/a-virtual-machine.html">https://craftinginterpreters.com/a-virtual-machine.html&lt;/a>&lt;/p>
&lt;p>[29] J. G. Guerrero, “Reinventing the wheel,” 2014.&lt;/p>
&lt;p>[30] C. O’Toole-Bateman, “The History of the Game Engine: Part 5 – Reinventing the Wheel.” &lt;a href="https://ultimategamingparadise.com/features/series/history-of-the-game-engine/part-5-reinventing-the-wheel/">https://ultimategamingparadise.com/features/series/history-of-the-game-engine/part-5-reinventing-the-wheel/&lt;/a>&lt;/p></description></item><item><title>C++ Compilation process</title><link>/posts/cpp_compilation_process/</link><pubDate>Thu, 02 Dec 2021 00:00:00 +0100</pubDate><guid>/posts/cpp_compilation_process/</guid><description>&lt;blockquote>
&lt;p>This is a workshop created for &lt;a href="https://www.buas.nl/en/programmes/creative-media-and-game-technologies">Breda University of Applied Sciences&lt;/a> 2021 with the original title: &lt;code>C++ Compilation process Workshop 2021&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>In this workshop / how to you learn how the C++ Compilation process works in a nutshell. Before you can start you need to do some form of preps as described in the next step.&lt;/p>
&lt;h2 id="preparations">Preparations&lt;/h2>
&lt;p>In order to participate you need to install the right compiler and linker.&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;p>If we have Visual Studio 19/22 installed with the C++ extensions or VS Code with the C++ tooling we have our linker and compiler installed.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> How to use the compiler from the command line follow this guide &lt;a href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Linux&lt;/strong> Debain/Ubuntu&lt;/p>
&lt;p>On Linux we need to install the basic build essentials. This includes the default compiler (usually GCC GNU C Compiler) and the linker&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> if you want to use the WSL follow these instructions &lt;a href="https://docs.microsoft.com/en-us/windows/wsl/install">https://docs.microsoft.com/en-us/windows/wsl/install&lt;/a> and than use the windows store / Microsoft store and download Ubuntu or Debian&lt;/p>
&lt;/blockquote>
&lt;p>Install (gcc):&lt;/p>
&lt;pre>&lt;code>sudo apt update
sudo apt install build-essential
gcc --version
&lt;/code>&lt;/pre>
&lt;p>Install (clang)&lt;/p>
&lt;pre>&lt;code>sudo apt update
sudo apt install clang
clang --version
&lt;/code>&lt;/pre>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>The C/C++ compilation process takes one source file at the time and creates a Translation unit of them. Individually they do not now anything of each other! The linker will combine them at the end.&lt;/p>
&lt;p>The compilation process of a translation unit (TU) looks as following:&lt;/p>
&lt;ol>
&lt;li>Source files are cleaned&lt;/li>
&lt;li>We parse the file and run the pre-processor
&lt;ol>
&lt;li>each introduced include goes into step 1&lt;/li>
&lt;li>All pre-processor directives are removed from the source.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Literal strings and characters are translated&lt;/li>
&lt;li>Compilation takes place of tokens: &lt;em>translation units&lt;/em>&lt;/li>
&lt;li>Template instanton happens &lt;code>instantiation units&lt;/code>&lt;/li>
&lt;li>Linking&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> Some compilers don&amp;rsquo;t implement instantiation units (also known as &lt;a href="http://docs.oracle.com/cd/E18659_01/html/821-1383/bkagr.html#scrolltoc">template repositories&lt;/a> or &lt;a href="http://www-01.ibm.com/support/knowledgecenter/SSXVZZ_12.1.0/com.ibm.xlcpp121.linux.doc/compiler_ref/fcat_template.html?lang=en">template registries&lt;/a>) and simply compile each template instantiation at Phase 7 (4), storing the code in the object file where it is implicitly or explicitly requested, and then the linker collapses these compiled instantiations into one at Phase 9 (6). (&lt;a href="https://en.cppreference.com/w/cpp/language/translation_phases">https://en.cppreference.com/w/cpp/language/translation_phases&lt;/a>)&lt;/p>
&lt;/blockquote>
&lt;h2 id="pre-processor">Pre-processor&lt;/h2>
&lt;p>Did we not forget the pre-processor?&lt;/p>
&lt;pre>&lt;code>#define value 1
// I am a comment
int main(){
int var{value};
}
&lt;/code>&lt;/pre>
&lt;p>If we now compile this we can store the pre processor output in a file:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /c /P preprocessor.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>gcc preprocessor.cpp -E&amp;gt;preprocessor.i
clang preprocessor.cpp -E&amp;gt;preprocessor.i
&lt;/code>&lt;/pre>
&lt;p>We now see a file names: &lt;code>preprocessor.i&lt;/code> :&lt;/p>
&lt;pre>&lt;code>#line 1 &amp;quot;preprocessor.cpp&amp;quot;
int main(){
int var{1};
}
&lt;/code>&lt;/pre>
&lt;p>The line &lt;code>int var{value};&lt;/code> has been changed to &lt;code>int var{1};&lt;/code> and the &lt;code>#define value 1&lt;/code> was erased! Also the comment was removed!&lt;/p>
&lt;h3 id="inclusion">Inclusion&lt;/h3>
&lt;p>If you include any header file the pre processor will include them recursively.&lt;/p>
&lt;pre>&lt;code>headerA.hpp
struct StructA{};
headerB.hpp
#include &amp;quot;headerA.hpp&amp;quot;
struct StructB{};
source.cpp
#include &amp;quot;headerB.hpp&amp;quot;
int main(){
StructA struct_a{};
}
&lt;/code>&lt;/pre>
&lt;p>If we now compile this we can store the pre processor output in a file:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /c /P source.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-c">gcc preprocessor.cpp -E&amp;gt;preprocessor.i
clang preprocessor.cpp -E&amp;gt;preprocessor.i
&lt;/code>&lt;/pre>
&lt;p>We now see a file names: &lt;code>source.i&lt;/code> or &lt;code>linux&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-cpp"># 1 &amp;quot;preprocessor/source.cpp&amp;quot;
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 1
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 3
# 383 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 3
# 1 &amp;quot;&amp;lt;command line&amp;gt;&amp;quot; 1
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 2
# 1 &amp;quot;preprocessor/source.cpp&amp;quot; 2
# 1 &amp;quot;preprocessor/headerB.hpp&amp;quot; 1
# 1 &amp;quot;preprocessor/headerA.hpp&amp;quot; 1
struct StructA{};
# 2 &amp;quot;preprocessor/headerB.hpp&amp;quot; 2
struct StructB{};
# 2 &amp;quot;preprocessor/source.cpp&amp;quot; 2
int main(){
StructA struct_a{};
}
&lt;/code>&lt;/pre>
&lt;h3 id="header-guards">Header Guards&lt;/h3>
&lt;p>As you could see Includes are recursive this can lead to cycle includes.&lt;/p>
&lt;pre>&lt;code>cycleA.hpp
#include &amp;quot;cycleB.hpp&amp;quot;
cycleB.hpp
#include &amp;quot;cycleA.hpp&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>if we now compile this with (clang, gcc, msvc)&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /c /P cycleA.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang cycleA.hpp -E&amp;gt;cycleA.i
gcc cycleA.hpp -E&amp;gt;cycleA.i
&lt;/code>&lt;/pre>
&lt;p>Result will be:&lt;/p>
&lt;pre>&lt;code class="language-bash">user@MININT-DAH9RK3:/mnt/d/cpplecture$ clang cycleA.hpp -E&amp;gt;preprocessor.i
In file included from preprocessor/cycleA.hpp:1:
In file included from preprocessor/cycleB.hpp:1:
In file included from preprocessor/cycleA.hpp:1:
[edit by Simon replaced 200 more of `In file included from preprocessor/cycleA.hpp:1:` with this line]
preprocessor/cycleB.hpp:1:10: error: #include nested too deeply
#include &amp;quot;cycleA.hpp&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>if we add now a &lt;code>#pragma once&lt;/code> to &lt;code>cycleB.hpp&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-c">#pragma once
#include &amp;quot;cycleA.hpp&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>the compiler (clang, gcc, msvc) will run and spill out:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /c /P cycleA.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang cycleA.hpp -E&amp;gt;cycleA.i
gcc cycleA.hpp -E&amp;gt;cycleA.i
&lt;/code>&lt;/pre>
&lt;p>The result:&lt;/p>
&lt;pre>&lt;code class="language-c"># 1 &amp;quot;preprocessor/cycleA.hpp&amp;quot;
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 1
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 3
# 383 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 3
# 1 &amp;quot;&amp;lt;command line&amp;gt;&amp;quot; 1
# 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 2
# 1 &amp;quot;preprocessor/cycleA.hpp&amp;quot; 2
# 1 &amp;quot;preprocessor/cycleB.hpp&amp;quot; 1
# 1 &amp;quot;preprocessor/cycleA.hpp&amp;quot; 1
# 2 &amp;quot;preprocessor/cycleB.hpp&amp;quot; 2
# 1 &amp;quot;preprocessor/cycleA.hpp&amp;quot; 2
&lt;/code>&lt;/pre>
&lt;h2 id="compile-a-source-file">Compile a source file&lt;/h2>
&lt;p>The basic source file:&lt;/p>
&lt;pre>&lt;code class="language-c++">int main(){}
&lt;/code>&lt;/pre>
&lt;p>Invoke the compiler:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /c empty.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang -c empty.cpp
gcc -c empty.cpp
&lt;/code>&lt;/pre>
&lt;p>This generates a object file. &lt;code>.obj&lt;/code> or &lt;code>.o&lt;/code> on linux.&lt;/p>
&lt;h2 id="assembler">Assembler&lt;/h2>
&lt;p>This way we skipped one step: The assembler! This is the step in which the compiler creates a assembly representation for your target platform!&lt;/p>
&lt;p>To get the output that is used to generate the Object File you must tell the compiler to generate the assemble output for you:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cl.exe /FAs /c empty.cpp
&lt;/code>&lt;/pre>
&lt;p>This will produce as &lt;code>.asm&lt;/code> file with your assembly&lt;/p>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang -S
&lt;/code>&lt;/pre>
&lt;p>This will produce a &lt;code>.s&lt;/code> file with your assembly.&lt;/p>
&lt;h3 id="inspecting-a-object-file">Inspecting a object file&lt;/h3>
&lt;p>Normally the compiler does the assembler step automatically and generates the object file. A object file contains all important information about the current translation unit. The most important question is: Which external objects are references? This is important since a TU does not know anything about other TU&amp;rsquo;s! The linker needs this information later to stitch the program together!&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> A Object file is on windows and Linux Systems different. Since on Windows it is a COFF generated by Microsoft C compiler and on Linux ELF/DWARF.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/COFF">https://en.wikipedia.org/wiki/COFF&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>We can view a Object file with:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;p>More infos: &lt;a href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-options?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-options?view=msvc-170&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-bash">DUMPBIN.EXE /ALL empty.obj
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-bash">objectdump -a empty.o
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> There could be a entire lecture about this! &lt;a href="https://www.youtube.com/watch?v=a5L66zguFe4">https://www.youtube.com/watch?v=a5L66zguFe4&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="linker">Linker&lt;/h2>
&lt;p>In this stage of the process multiple object files will be combined to a executable!&lt;/p>
&lt;h3 id="executable">Executable&lt;/h3>
&lt;p>Lets build a game:&lt;/p>
&lt;pre>&lt;code>/game/main.cpp
/lib/engine.hpp
/lib/engine.cpp
main.cpp
#include &amp;quot;engine.hpp&amp;quot;
int main(){
engine{create()};
}
engine.hpp
struct engine{
// stuff
};
[[nodiscard]] engine create() noexcept;
engine.cpp
#include &amp;quot;engine.hpp&amp;quot;
[[nodiscard]] engine create() noexcept{
return {};
}
&lt;/code>&lt;/pre>
&lt;p>Let us compile the game:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-bash">cd /game
cl.exe \c main.cpp
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cd /game
clang -c main.cpp -std=c++17
gcc -c main.cpp -std=c++17
&lt;/code>&lt;/pre>
&lt;p>This will spill out a compile error!&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; cl.exe /c main.cpp
Microsoft (R) C/C++ Optimizing Compiler Version 19.29.30136 for x86
Copyright (C) Microsoft Corporation. All rights reserved.
main.cpp
main.cpp(1): fatal error C1083: Cannot open include file: 'engine.hpp': No such file or directory
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> On Linux we will have the same result!&lt;/p>
&lt;/blockquote>
&lt;p>We need to tell the compiler where the header file is! &lt;code>/I[..]&lt;/code> or &lt;code>-I[..]&lt;/code>&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; cl.exe /c main.cpp /I ../lib
&lt;/code>&lt;/pre>
&lt;p>This works! we have a obj file!&lt;/p>
&lt;p>Let us investigate what is in the object file: We run &lt;code>DUMPBIN.EXE /ALL main.obj&lt;/code>&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; DUMPBIN.EXE /ALL main.obj
Microsoft (R) COFF/PE Dumper Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file main.obj
File Type: COFF OBJECT
FILE HEADER VALUES
14C machine (x86)
4 number of sections
61A8E6C9 time date stamp Thu Dec 2 16:31:21 2021
193 file pointer to symbol table
D number of symbols
0 size of optional header
0 characteristics
SECTION HEADER #1
.drectve name
0 physical address
0 virtual address
2F size of raw data
B4 file pointer to raw data (000000B4 to 000000E2)
0 file pointer to relocation table
0 file pointer to line numbers
0 number of relocations
0 number of line numbers
100A00 flags
Info
Remove
1 byte align
RAW DATA #1
00000000: 20 20 20 2F 44 45 46 41 55 4C 54 4C 49 42 3A 22 /DEFAULTLIB:&amp;quot;
00000010: 4C 49 42 43 4D 54 22 20 2F 44 45 46 41 55 4C 54 LIBCMT&amp;quot; /DEFAULT
00000020: 4C 49 42 3A 22 4F 4C 44 4E 41 4D 45 53 22 20 LIB:&amp;quot;OLDNAMES&amp;quot;
Linker Directives
-----------------
/DEFAULTLIB:LIBCMT
/DEFAULTLIB:OLDNAMES
SECTION HEADER #2
.debug$S name
0 physical address
0 virtual address
74 size of raw data
E3 file pointer to raw data (000000E3 to 00000156)
0 file pointer to relocation table
0 file pointer to line numbers
0 number of relocations
0 number of line numbers
42100040 flags
Initialized Data
Discardable
1 byte align
Read Only
RAW DATA #2
00000000: 04 00 00 00 F1 00 00 00 67 00 00 00 29 00 01 11 ....ñ...g...)...
00000010: 00 00 00 00 44 3A 5C 63 70 70 6C 65 63 74 75 72 ....D:\cpplectur
00000020: 65 5C 6C 69 6E 6B 65 72 5C 67 61 6D 65 5C 6D 61 e\linker\game\ma
00000030: 69 6E 2E 6F 62 6A 00 3A 00 3C 11 01 22 00 00 07 in.obj.:.&amp;lt;..&amp;quot;...
00000040: 00 13 00 1D 00 B8 75 00 00 13 00 1D 00 B8 75 00 .....¸u......¸u.
00000050: 00 4D 69 63 72 6F 73 6F 66 74 20 28 52 29 20 4F .Microsoft (R) O
00000060: 70 74 69 6D 69 7A 69 6E 67 20 43 6F 6D 70 69 6C ptimizing Compil
00000070: 65 72 00 00 er..
SECTION HEADER #3
.text$mn name
0 physical address
0 virtual address
12 size of raw data
157 file pointer to raw data (00000157 to 00000168)
169 file pointer to relocation table
0 file pointer to line numbers
1 number of relocations
0 number of line numbers
60500020 flags
Code
16 byte align
Execute Read
RAW DATA #3
00000000: 55 8B EC 51 E8 00 00 00 00 88 45 FF 33 C0 8B E5 U.ìQè.....Eÿ3À.å
00000010: 5D C3 ]Ã
RELOCATIONS #3
Symbol Symbol
Offset Type Applied To Index Name
-------- ---------------- ----------------- -------- ------
00000005 REL32 00000000 9 ?create@@YA?AUengine@@XZ (struct engine __cdecl create(void))
SECTION HEADER #4
.chks64 name
0 physical address
0 virtual address
20 size of raw data
173 file pointer to raw data (00000173 to 00000192)
0 file pointer to relocation table
0 file pointer to line numbers
0 number of relocations
0 number of line numbers
A00 flags
Info
Remove
(no align specified)
RAW DATA #4
00000000: 23 07 66 15 27 1A BF 1A FD FD 6A 15 8D E6 A5 E2 #.f.'.¿.ýýj..æ¥â
00000010: 42 E8 D5 96 AB C2 64 E1 00 00 00 00 00 00 00 00 BèÕ.«Âdá........
COFF SYMBOL TABLE
000 010575B8 ABS notype Static | @comp.id
001 80010191 ABS notype Static | @feat.00
002 00000002 ABS notype Static | @vol.md
003 00000000 SECT1 notype Static | .drectve
Section length 2F, #relocs 0, #linenums 0, checksum 0
005 00000000 SECT2 notype Static | .debug$S
Section length 74, #relocs 0, #linenums 0, checksum 0
007 00000000 SECT3 notype Static | .text$mn
Section length 12, #relocs 1, #linenums 0, checksum 6BED4AA5
009 00000000 UNDEF notype () External | ?create@@YA?AUengine@@XZ (struct engine __cdecl create(void))
00A 00000000 SECT3 notype () External | _main
00B 00000000 SECT4 notype Static | .chks64
Section length 20, #relocs 0, #linenums 0, checksum 0
String Table Size = 0x1D bytes
Summary
20 .chks64
74 .debug$S
2F .drectve
12 .text$mn
&lt;/code>&lt;/pre>
&lt;p>Under &lt;code>RELOCATIONS #3&lt;/code> we find something intersting:&lt;/p>
&lt;pre>&lt;code> Symbol Symbol
Offset Type Applied To Index Name
00000005 REL32 00000000 9 ?create@@YA?AUengine@@XZ (struct engine __cdecl create(void))
&lt;/code>&lt;/pre>
&lt;p>This somehow looks like: &lt;code>[[nodiscard ]] engine create() noexcept&lt;/code>. That is correct! In C++ we mangle names we (the compiler) renames the name after they implementation defined scheme (yes clang uses a different method than msvc! GREAT!)&lt;/p>
&lt;blockquote>
&lt;p>The reason for this is that we can have overloads (in short!) more infos here &lt;a href="https://www.geeksforgeeks.org/extern-c-in-c/">https://www.geeksforgeeks.org/extern-c-in-c/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>This means the compiler stores in the object file all sorts of interesting information about this TU (translation unit). In this case the compiler stores that at a offset of 5 the symbol &lt;code>?create@@YA?AUengine@@XZ (struct engine __cdecl create(void))&lt;/code> needs to be relocated! Relocated means that it can be found external!&lt;/p>
&lt;p>Enough of this inspection lets us create our executable!&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; link.exe main.obj
&lt;/code>&lt;/pre>
&lt;p>This also leads to a error!&lt;/p>
&lt;pre>&lt;code class="language-cpp">Microsoft (R) Incremental Linker Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
main.obj : error LNK2019: unresolved external symbol &amp;quot;struct engine __cdecl create(void)&amp;quot; (?create@@YA?AUengine@@XZ) referenced in function _main
main.exe : fatal error LNK1120: 1 unresolved externals
&lt;/code>&lt;/pre>
&lt;p>Do we remember:&lt;/p>
&lt;blockquote>
&lt;p>This means the compiler stores in the object file all sorts of interesting information about this TU (translation unit). In this case the compiler stores that at a offset of 5 the symbol &lt;code>?create@@YA?AUengine@@XZ (struct engine __cdecl create(void))&lt;/code> needs to be relocated! Relocated means that it can be found external!&lt;/p>
&lt;/blockquote>
&lt;p>This is what it means in practice! Oh right we did not compile &lt;code>lib/engine.cpp&lt;/code> Let us fix this!&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; cd ..
PS D:\cpplecture\linker&amp;gt; cd lib
PS D:\cpplecture\linker\lib&amp;gt; cl.exe /c engine.cpp
&lt;/code>&lt;/pre>
&lt;p>Now we have a &lt;code>lib/engine.obj&lt;/code>&lt;/p>
&lt;p>cool lets go back to our game and try again!&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; link.exe main.obj
Microsoft (R) Incremental Linker Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
main.obj : error LNK2019: unresolved external symbol &amp;quot;struct engine __cdecl create(void)&amp;quot; (?create@@YA?AUengine@@XZ) referenced in function _main
main.exe : fatal error LNK1120: 1 unresolved externals
&lt;/code>&lt;/pre>
&lt;p>We get the same error! But we compiled the other thing&amp;hellip;&lt;/p>
&lt;p>This time we have to remmeber:&lt;/p>
&lt;blockquote>
&lt;p>Translation Units are looked at individually and main.obj does not know anything of engine.obj!&lt;/p>
&lt;/blockquote>
&lt;p>This means we need to tell the linker &lt;strong>where&lt;/strong> our external symbols are living!&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; link.exe main.obj ../lib/engine.obj
&lt;/code>&lt;/pre>
&lt;p>This works we get out executable!&lt;/p>
&lt;h3 id="library">Library&lt;/h3>
&lt;p>In reality projects are really big and sometimes we split them into libraries. In general a library is nothing else than a collection of object files the linker can use statically or dynamically!&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> This overview will not touch the dynamic approach since this is a huge topic on its own!&lt;/p>
&lt;/blockquote>
&lt;p>Lets upgrade our &amp;ldquo;engine&amp;rdquo; example a bit:&lt;/p>
&lt;pre>&lt;code>engine.hpp
#pragma once
using cstring = const char*;
template&amp;lt;typename T&amp;gt;
struct container_t{
T* items;
unsigned int num_items;
unsigned int capacity;
};
struct entity_t {
unsigned int id;
};
struct world_t{
container_t&amp;lt;entity_t&amp;gt; entities;
};
struct engine_t{
void update(double dt);
entity_t spawn();
world_t world;
};
[[nodiscard ]] engine_t create() noexcept;
#include &amp;quot;engine.hpp&amp;quot;
[[nodiscard]] engine_t create() noexcept{
engine_t e{};
e.world.entities.items = new entity_t[100];
e.world.entities.capacity = 100;
return e;
}
entity_t engine_t::spawn(){
if(world.entities.num_items == world.entities.capacity){
// magic
}else{
world.entities.items[world.entities.num_items] = {world.entities.num_items};
}
return {world.entities.num_items};
}
void engine_t::update(double dt){
//...
}
&lt;/code>&lt;/pre>
&lt;p>Let us add a json parser &amp;hellip; every good C++ project needs one!&lt;/p>
&lt;pre>&lt;code>json.hpp
#pragma once
using cstring = const char*;
struct string_view{
cstring data_ptr;
unsigned int len;
};
struct json{
//..
};
struct json_object{
//..
};
struct json_array{
json_object* objects;
unsigned int len;
};
[[nodiscard]] json parse(cstring path) noexcept;
[[nodiscard]] json_object get_object(const json&amp;amp; root,cstring key) noexcept;
[[nodiscard]] json_array get_array(const json&amp;amp; root,cstring key) noexcept;
[[nodiscard]] string_view get_string(const json&amp;amp; root,cstring key) noexcept;
[[nodiscard]] double get_number(const json&amp;amp; root,cstring key) noexcept;
#include &amp;quot;json.hpp&amp;quot;
[[nodiscard]] json parse(cstring path) noexcept{
return {};
}
[[nodiscard]] json_object get_object(const json&amp;amp; root,cstring key) noexcept{
return {};
}
[[nodiscard]] json_array get_array(const json&amp;amp; root,cstring key) noexcept{
return {};
}
[[nodiscard]] string_view get_string(const json&amp;amp; root,cstring key) noexcept{
return {};
}
[[nodiscard]] double get_number(const json&amp;amp; root,cstring key) noexcept{
return {};
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>The game:&lt;/strong>&lt;/p>
&lt;pre>&lt;code>level.hpp
#include &amp;quot;engine.hpp&amp;quot;
struct level{
world_t world;
};
void load(engine_t&amp;amp; engine, cstring level) noexcept;
level.cpp
#include &amp;quot;engine.hpp&amp;quot;
#include &amp;quot;json.hpp&amp;quot;
void load(engine_t&amp;amp; engine, cstring level) noexcept{
json l{parse(level)};
}
main.cpp
#include &amp;quot;engine.hpp&amp;quot;
#include &amp;quot;level.hpp&amp;quot;
int main(){
engine_t core{create()};
load(core,&amp;quot;Test_level.json&amp;quot;);
}
&lt;/code>&lt;/pre>
&lt;p>Let us build a &lt;code>.lib&lt;/code> or &lt;code>.a&lt;/code> file.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note&lt;/strong>: again a static lib is nothing else than a collection (or archive) or object files. This is why the name on Linux is .a which stands for &lt;em>archive&lt;/em> and the tool on Linux for creating one is called &lt;code>ar&lt;/code> &lt;a href="https://linux.die.net/man/1/ar">https://linux.die.net/man/1/ar&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>At first we need to compile both of our translation units (source files):&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>cd lib
PS D:\cpplecture\linker\lib&amp;gt; cl.exe /c engine.cpp json.cpp
--&amp;gt; engine.obj
--&amp;gt; json.obj
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang -c engine.cpp json.cpp -std=c++17
gcc -c engine.cpp json.cpp -std=c++17
--&amp;gt; json.o
--&amp;gt; engine.o
&lt;/code>&lt;/pre>
&lt;p>Now we need to stich those object files together this can be done via the &lt;code>lib.exe&lt;/code> or the &lt;code>ar&lt;/code> tool on linux:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code>lib.exe .\json.obj .\engine.obj /out:engine.lib
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;a href="https://docs.microsoft.com/en-us/cpp/build/reference/overview-of-lib?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/reference/overview-of-lib?view=msvc-170&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>ar rc engine.a json.o engine.o
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;a href="https://llvm.org/docs/CommandGuide/llvm-ar.html">https://llvm.org/docs/CommandGuide/llvm-ar.html&lt;/a> or &lt;a href="https://linux.die.net/man/1/ar">https://linux.die.net/man/1/ar&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Now we have a lib: &lt;code>engine.lib&lt;/code> or &lt;code>engine.a&lt;/code> and we can now link against this with &lt;code>ld&lt;/code> (on Linux) or &lt;code>link.exe&lt;/code> on windows just like we were to link object files:&lt;/p>
&lt;p>&lt;strong>Windows&lt;/strong>&lt;/p>
&lt;pre>&lt;code> cl.exe main.cpp level.cpp /c /I ../lib
link.exe .\main.obj .\level.obj ../lib/engine.lib /out:game.exe
--&amp;gt; game.exe
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Linux&lt;/strong>&lt;/p>
&lt;pre>&lt;code>clang main.cpp level.cpp -c -I ../lib
ld .\main.o .\level.o ../lib/engine.a -o game
--&amp;gt; game
&lt;/code>&lt;/pre>
&lt;h2 id="extra">Extra&lt;/h2>
&lt;p>If we now inspect the &lt;code>engine.obj&lt;/code>&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; DUMPBIN.EXE /RELOCATIONS engine.lib
Microsoft (R) COFF/PE Dumper Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file engine.lib
File Type: LIBRARY
RELOCATIONS #3
Symbol Symbol
Offset Type Applied To Index Name
-------- ---------------- ----------------- -------- ------
00000077 REL32 00000000 9 ??_U@YAPAXI@Z (void * __cdecl operator new[](unsigned int))
&lt;/code>&lt;/pre>
&lt;p>and for &lt;code>main.obj&lt;/code>&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; DUMPBIN.EXE /RELOCATIONS main.obj
Microsoft (R) COFF/PE Dumper Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file main.obj
File Type: COFF OBJECT
RELOCATIONS #4
Symbol Symbol
Offset Type Applied To Index Name
-------- ---------------- ----------------- -------- ------
0000000B REL32 00000000 C ?create@@YA?AUengine_t@@XZ (struct engine_t __cdecl create(void))
00000036 DIR32 00000000 9 $SG2851
0000003F REL32 00000000 D ?load@@YAXAAUengine_t@@PBD@Z (void __cdecl load(struct engine_t &amp;amp;,char const *))
&lt;/code>&lt;/pre>
&lt;p>We have 3:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Symbol&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>?create@@YA?AUengine_t@@XZ (struct engine_t __cdecl create(void))&lt;/code>&lt;/td>
&lt;td>&lt;code>[[nodiscard]] engine_t create() noexcept&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$SG2851&lt;/td>
&lt;td>dunno&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>?load@@YAXAAUengine_t@@PBD@Z (void __cdecl load(struct engine_t &amp;amp;,char const *))&lt;/code>&lt;/td>
&lt;td>&lt;code>void load(engine_t&amp;amp; engine, cstring level) noexcept&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>If we now look at what symbols we can find in &lt;code>engine.lib&lt;/code>:&lt;/p>
&lt;pre>&lt;code>PS D:\cpplecture\linker\game&amp;gt; DUMPBIN.EXE /SYMBOLS engine.lib
Microsoft (R) COFF/PE Dumper Version 14.29.30136.0
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file engine.lib
File Type: LIBRARY
COFF SYMBOL TABLE
000 010575B8 ABS notype Static | @comp.id
001 80010191 ABS notype Static | @feat.00
002 00000002 ABS notype Static | @vol.md
003 00000000 SECT1 notype Static | .drectve
Section length 2F, #relocs 0, #linenums 0, checksum 0
005 00000000 SECT2 notype Static | .debug$S
Section length 78, #relocs 0, #linenums 0, checksum 0
007 00000000 SECT3 notype Static | .text$mn
Section length A9, #relocs 1, #linenums 0, checksum 47C05A6
009 00000000 UNDEF notype () External | ??_U@YAPAXI@Z (void * __cdecl operator new[](unsigned int))
00A 00000000 SECT3 notype () External | ?update@engine_t@@QAEXN@Z (public: void __thiscall engine_t::update(double))
00B 00000010 SECT3 notype () External | ?spawn@engine_t@@QAE?AUentity_t@@XZ (public: struct entity_t __thiscall engine_t::spawn(void))
00C 00000060 SECT3 notype () External | ?create@@YA?AUengine_t@@XZ (struct engine_t __cdecl create(void))
00D 00000000 SECT4 notype Static | .chks64
Section length 20, #relocs 0, #linenums 0, checksum 0
String Table Size = 0x6B bytes
COFF SYMBOL TABLE
000 010575B8 ABS notype Static | @comp.id
001 80010191 ABS notype Static | @feat.00
002 00000002 ABS notype Static | @vol.md
003 00000000 SECT1 notype Static | .drectve
Section length 2F, #relocs 0, #linenums 0, checksum 0
005 00000000 SECT2 notype Static | .debug$S
Section length 74, #relocs 0, #linenums 0, checksum 0
007 00000000 SECT3 notype Static | .text$mn
Section length 67, #relocs 0, #linenums 0, checksum 789BEE7A
009 00000000 SECT3 notype () External | ?parse@@YA?AUjson@@PBD@Z (struct json __cdecl parse(char const *))
00A 00000010 SECT3 notype () External | ?get_object@@YA?AUjson_object@@ABUjson@@PBD@Z (struct json_object __cdecl get_object(struct json const &amp;amp;,char const *))
00B 00000020 SECT3 notype () External | ?get_array@@YA?AUjson_array@@ABUjson@@PBD@Z (struct json_array __cdecl get_array(struct json const &amp;amp;,char const *))
00C 00000040 SECT3 notype () External | ?get_string@@YA?AUstring_view@@ABUjson@@PBD@Z (struct string_view __cdecl get_string(struct json const &amp;amp;,char const *))
00D 00000060 SECT3 notype () External | ?get_number@@YANABUjson@@PBD@Z (double __cdecl get_number(struct json const &amp;amp;,char const *))
00E 00000000 UNDEF notype External | __fltused
00F 00000000 SECT4 notype Static | .rdata
Section length 8, #relocs 0, #linenums 0, checksum 0, selection 2 (pick any)
011 00000000 SECT4 notype External | __real@0000000000000000
012 00000000 SECT5 notype Static | .chks64
Section length 28, #relocs 0, #linenums 0, checksum 0
String Table Size = 0xE6 bytes
&lt;/code>&lt;/pre>
&lt;p>We get the list of all symbols in both object files: &lt;code>engine.obj&lt;/code> and &lt;code>json.obj&lt;/code>&lt;/p>
&lt;h2 id="references">References:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/cpp/build/reference/overview-of-lib?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/reference/overview-of-lib?view=msvc-170&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://llvm.org/docs/CommandGuide/llvm-ar.html">https://llvm.org/docs/CommandGuide/llvm-ar.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mottosso.gitbooks.io/clang/content/building_a_static_library.html">https://mottosso.gitbooks.io/clang/content/building_a_static_library.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gist.github.com/jsanchezuy/23b1fc8c592455f1bb84">https://gist.github.com/jsanchezuy/23b1fc8c592455f1bb84&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://man7.org/linux/man-pages/man1/objdump.1.html">https://man7.org/linux/man-pages/man1/objdump.1.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.computerhope.com/unix/uld.htm">https://www.computerhope.com/unix/uld.htm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options?view=msvc-170&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://linux.die.net/man/1/ar">https://linux.die.net/man/1/ar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.cppreference.com/w/cpp/language/translation_phases">https://en.cppreference.com/w/cpp/language/translation_phases&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/COFF">https://en.wikipedia.org/wiki/COFF&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-options?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-options?view=msvc-170&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=a5L66zguFe4">https://www.youtube.com/watch?v=a5L66zguFe4&lt;/a> (CppCon 2017: Michael Spencer “My Little Object File: How Linkers Implement C++”)&lt;/li>
&lt;li>&lt;a href="https://www.geeksforgeeks.org/extern-c-in-c/">https://www.geeksforgeeks.org/extern-c-in-c/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ibm.com/docs/en/i/7.2?topic=linkage-name-mangling-c-only">https://www.ibm.com/docs/en/i/7.2?topic=linkage-name-mangling-c-only&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://web.mit.edu/tibbetts/Public/inside-c/www/mangling.html">http://web.mit.edu/tibbetts/Public/inside-c/www/mangling.html&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Internship at OurMachinery</title><link>/project/themachinery/</link><pubDate>Tue, 01 Jun 2021 14:10:00 +0100</pubDate><guid>/project/themachinery/</guid><description>&lt;p>&lt;a href="http://www.ourmachinery.com">The Machinery&lt;/a> is a lightweight hackable modern game engine, written
in plain C.Written in plain C. Boots instantly. Responsive UI. Recompiles in seconds. Supports hot
reloading everywhere. Made to be hacked. Extend or modify with plugins. The flexibility of a custom
engine with the convenience of a ready-made one.Maximum performance. Fiber-based job system. Modern
rendering architecture.&lt;/p>
&lt;h2 id="my-main-responsibilities">My main responsibilities&lt;/h2>
&lt;p>&lt;strong>Tools Engineering&lt;/strong>&lt;/p>
&lt;p>During my internship I have been in charge for multiple improvements of the UX of the Editor. I have
introduced different views to the Asset Browser, which are modeled after the Windows Explorer: Grid,
List, Detail View. Besides, I have introduced the concept of asset labels, which allows for quick
grouping assets together with labels. Also the user can filter with those labels assets.&lt;/p>
&lt;p>The bigger tasks was to introduce a Debugger to our Visual Scripting language. This was were most of
my time went. I introduced breakpoints, flow visualization, step through and a watch value functionality.&lt;/p>
&lt;p>&lt;strong>QA Engineering&lt;/strong>&lt;/p>
&lt;p>I am working with GitHub Actions. It verifies that our engine can be built on Windows (&lt;code>msvc&lt;/code> and
&lt;code>clang-cl&lt;/code>) and Linux (our test environment is Ubuntu) with the clang tool chain. Besides I have
been adding functionality of integration tests to the CI system on the server, Integration tests and
unit tests are running side by side in specific intervals (Unit tests every commit or PR)&lt;/p></description></item><item><title>Imposter Effect Lightning Talk Meetingcpp 2019</title><link>/talk/imposter-effect-lightning-talk-meetingcpp19/</link><pubDate>Fri, 15 Nov 2019 20:50:00 +0100</pubDate><guid>/talk/imposter-effect-lightning-talk-meetingcpp19/</guid><description/></item><item><title>Imposter Effect Lightning Talk Meetingcpp 2019</title><link>/talk/imposter-effect-lightning-talk-meetingcpp19/</link><pubDate>Fri, 15 Nov 2019 20:50:00 +0100</pubDate><guid>/talk/imposter-effect-lightning-talk-meetingcpp19/</guid><description/></item><item><title>“Tomorrow Engine“</title><link>/project/tbsg/</link><pubDate>Wed, 01 May 2019 20:19:00 +0100</pubDate><guid>/project/tbsg/</guid><description>&lt;p>The tomorrow engine is a cross platform C++ game framework which allows the creation of deterministic linear card games. The player had to fight the opponent and the 3 monsters in the game. The game we created with this was called Raptoads. The Framework supported Playstation 4 and Windows 10.&lt;/p>
&lt;h2 id="gameplay-trailer">Gameplay trailer&lt;/h2>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/KfBd1vJM9wI" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="my-main-responsibilities">My main responsibilities&lt;/h2>
&lt;p>Apart from being the Tech lead / Team lead of the 11 programmers, I have been in charge for the core architecture. Besides, I have been responsible for implementing and designing the extensive tooling and pipeline for content creation and content management. The tooling was created in web technologies (electron &amp;amp; SQL Database), which allowed us for quick and rapid iterations.&lt;/p>
&lt;h3 id="core-architecture">Core Architecture&lt;/h3>
&lt;p>The application was split into four different modules. The Framework (TBSG) served the Client as well as the Server with basic utilities. Besides, we had the Network layer.&lt;/p>
&lt;p>When designing the modules, I followed the architecture guideline for our game: &lt;em>determinstic linear card games&lt;/em>. That resulted in a &amp;ldquo;data oriented&amp;rdquo; approach.&lt;/p>
&lt;h3 id="tooling---the-hub">Tooling - The Hub&lt;/h3>
&lt;p>The framework came with its own tooling which was written in JavaScript and Electron. It served as the main content creation tool for Designers. The tool offered the following functions:&lt;/p>
&lt;ul>
&lt;li>AI Optimization for the QA Test games&lt;/li>
&lt;li>Modifiying the underlying content database (SQL)&lt;/li>
&lt;li>source contol of our Lua card scripts&lt;/li>
&lt;li>UI Editor&lt;/li>
&lt;li>Lua Script validation&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Project Information&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Duration:&lt;/td>
&lt;td>16 Weeks - February to July 2019&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Team size:&lt;/td>
&lt;td>11 Programmers, 5 Designers, 8 Artists and 1 Producer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Roles:&lt;/td>
&lt;td>Tech Lead, Tools programmer, Scrum Master&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Engine:&lt;/td>
&lt;td>Custom cross-platform C++ Engine with Electron Tooling (Tomorrow Engine)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Platform:&lt;/td>
&lt;td>Windows, Playstation 4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Languages:&lt;/td>
&lt;td>C++, JavaScript, Lua, SQL&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Technologies:&lt;/td>
&lt;td>Lua Scripting, Online Crossplay Multiplayer, Event/HTTP/UI handling with PS4 Support.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Project Highlights&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Scripting Pipeline: A Lua dialect which allowed designers to quickly develop with our tooling the card behaviour.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Scripting source control integration - via the tooling&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Google Drive integration &amp;amp; Sheets&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Utility AI - custimizeble via the tooling&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Custom Tooling written with Web technologies for quick iterations, tool of choice: Electron &amp;amp; MariaDB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Playstation 4 Support: The engine supported Playstation 4&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Tutoring</title><link>/project/tutoring/</link><pubDate>Sat, 15 Dec 2018 21:19:00 +0100</pubDate><guid>/project/tutoring/</guid><description>&lt;p>I have been giving workshops and lectures since my second year at the university. This is a great way of learning new skills and sharing the gained knowlegde with others. It also allows for a great flow of feedback. This is why I initiated the C++ learning comminity at our school (called C++ Guild)&lt;/p>
&lt;p>In the last two years I have been giving various lectures and workshops on the following topics:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Lecture / Workshop&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>How do programmers think?&lt;/td>
&lt;td>A lecture which uses minecraft to illustrate how abstract thinking works as well as how we can improve communication internally.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C++ type deduction&lt;/td>
&lt;td>In three workshops I have covered the basics of the C++ type deduction: template type deduction, auto type deduction, decltype deduction, decltype auto deduction, lambda type deduction.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C++ Compiler and linker steps&lt;/td>
&lt;td>This presentation explained the compiler steps in C++ and the linker steps.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Allocators are handles to the heap&lt;/td>
&lt;td>This workshop introduced the concept of polymorphic memory allocations in C++17 and how to use them as well as how to implement them in C++14. Besides, there was a brief introduction on Memory Management.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C++ special member function rules&lt;/td>
&lt;td>In this talk I covered the special member function rules in C++.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C# for designers and artists&lt;/td>
&lt;td>This is a workshop series of 16 weeks in which me and 2 other students taught C# to fellow Design and Art students. We ran this course in year 2 and also in year 3. We iterated on the idea and changed the concept to a Quest-based learning environment. This allows students to progress at their own pace because they have an overview on how they progress.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C++ Memory Managment: Introduction&lt;/td>
&lt;td>In two parts I introduced Memory Managment in C++ and the underlying concepts.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C++ Memory Managment: Write your own STL compatible allocator&lt;/td>
&lt;td>This workshop explained how to implement in C++ 14 an STL compatible polymorphic like allocator and memory resource environment. This workshop was targeted for Windows and Playstation 4 and was held in 4 parts.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>